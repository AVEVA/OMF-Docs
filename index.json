{
    "documentation/HttpBehaviors/Http_Status_Codes.html":  {
                                                               "href":  "documentation/HttpBehaviors/Http_Status_Codes.html",
                                                               "title":  "HTTP Status Codes | OSIsoft Message Format",
                                                               "keywords":  "HTTP Status Codes The following status codes are returned by OSIsoft products accepting OMF messages over HTTP. Status code Description 200 OK The OMF message was successfully processed. Response body contains additional information. 202 Accepted The OMF message was received and has been successfully queued to be processed. 204 No Content The OMF message was successfully processed, but there is no additional information to return. 400 Bad Request The OMF message was malformed or not understood. The client should not retry sending the message without modifications. 401 Unauthorized Authentication failed. 403 Forbidden Authentication succeeded, but not authorized. 413 Payload Too Large Payload size exceeds OMF body size limit. 500 Internal Server Error The server encountered an unexpected condition. 503 Service Unavailable The server is currently unavailable, retry later."
                                                           },
    "documentation/HttpBehaviors/Message_Size.html":  {
                                                          "href":  "documentation/HttpBehaviors/Message_Size.html",
                                                          "title":  "Message Size | OSIsoft Message Format",
                                                          "keywords":  "Message Size The body of an OMF message has a maximum size of 192KB. A request with a body size exceeding the maximum will be rejected with an HTTP response code of 413 Payload Too Large . Compression is highly recommended for optimal performance."
                                                      },
    "documentation_v10/Containers/Container_Messages.html":  {
                                                                 "href":  "documentation_v10/Containers/Container_Messages.html",
                                                                 "title":  "Container Messages | OSIsoft Message Format",
                                                                 "keywords":  "Container Messages A Container is defined as a collection of Data events of identical Type and version. Each Container has a unique ID, defined upon creation of the Container. Once a Type has been registered with a Type message, Containers can begin using that Type. Containers can be created, updated, or deleted. The body of a Container message consists of an array of objects with the following keywords: Name Value id Unique identifier of the Container. typeid ID of the Type used by the Container. typeversion Optional version of the Type used by the Container. The version must be of format x.x.x.x, where x must be an integer greater than or equal to 0. If omitted, version 1.0.0.0 is used. name Optional friendly name for the Container. description Optional description for the Container. tags Optional array of strings to tag the Container. metadata Optional key-value pairs associated with the Container. Example of Container Message Container Example"
                                                             },
    "documentation_v10/Containers/Container_Msg_Example.html":  {
                                                                    "href":  "documentation_v10/Containers/Container_Msg_Example.html",
                                                                    "title":  "Container Example | OSIsoft Message Format",
                                                                    "keywords":  "Container Example Headers producertoken = b7CNvN36cq omfversion = 1.0 messagetype = container action = create messageformat = json Body [{ \"id\": \"Tank1Measurements\", \"typeid\": \"TankMeasurement\", \"typeVersion\": \"1.0.0.0\" }, { \"id\": \"Tank2Measurements\", \"typeid\": \"TankMeasurement\", \"typeVersion\": \"1.0.0.0\" }]"
                                                                },
    "documentation_v10/Data/Data_Messages.html":  {
                                                      "href":  "documentation_v10/Data/Data_Messages.html",
                                                      "title":  "Data Messages | OSIsoft Message Format",
                                                      "keywords":  "Data Messages Data messages can span multiple Types and Containers. The body of a Data message is composed of an array of objects with the following keywords: Name Value typeid Optional ID of the type. If omitted, container is expected. containerid Optional ID of the container. If omitted, type is expected. typeversion Optional version of the Type, if one is specified. The version must be of format x.x.x.x, where x must be an integer greater than or equal to 0. If omitted, version 1.0.0.0 is assumed. values An array of objects conforming to the type. For each object, either typeid or containerid must be specified. If containerid is specified, the values must conform to the Type with which the Container is associated. If typeid is specified, the values must conform to that Type. If a Type Property is defined but no property value is provided in the Data message, a default value will be assumed. Default values are specified in Type Properties and Formats . Example of Data Message Data Example"
                                                  },
    "documentation_v10/Data/Data_Msg_Example.html":  {
                                                         "href":  "documentation_v10/Data/Data_Msg_Example.html",
                                                         "title":  "Data Example | OSIsoft Message Format",
                                                         "keywords":  "Data Example Headers producertoken = b7CNvN36cq omfversion = 1.0 messagetype = data action = create messageformat = json Body [{ \"typeid\": \"Plant\", \"values\": [{ \"PlantId\": \"PlantId1\", \"PlantName\": \"Plant1\", \"Address\": \"123 Meridian Ave\", \"Contact\": \"Bob Ross\" }] }, { \"typeid\": \"Tank\", \"values\": [{ \"TankName\": \"Tank1\", \"Serial\": \"5236-3523-KKF4\", \"Model\": \"FN-2187\" }, { \"TankName\": \"Tank2\", \"Serial\": \"2364-4243-FS12\", \"Model\": \"TK-421\" }] }, { \"typeid\": \"__Link\", \"values\": [{ \"source\": { \"typeid\": \"Plant\", \"index\": \"PlantId1\" }, \"target\": { \"typeid\": \"Tank\", \"index\": \"Tank1\" } }, { \"source\": { \"typeid\": \"Plant\", \"index\": \"PlantId1\" }, \"target\": { \"typeid\": \"Tank\", \"index\": \"Tank2\" } }, { \"source\": { \"typeid\": \"Tank\", \"index\": \"Tank1\" }, \"target\": { \"containerid\": \"Tank1Measurements\" } }, { \"source\": { \"typeid\": \"Tank\", \"index\": \"Tank2\" }, \"target\": { \"containerid\": \"Tank2Measurements\" } }] }, { \"containerid\": \"Tank1Measurements\", \"values\": [{ \"Time\": \"2017-01-11T22:23:23.430Z\", \"Pressure\": 12.0, \"Temperature\": 100.1 }, { \"Time\": \"2017-01-11T22:24:23.430Z\", \"Pressure\": 11.5, \"Temperature\": 101.2 }] }, { \"containerid\": \"Tank2Measurements\", \"values\": [{ \"Time\": \"2017-01-11T22:23:23.430Z\", \"Pressure\": 14.0, \"Temperature\": 90.1 }, { \"Time\": \"2017-01-11T22:24:23.430Z\", \"Pressure\": 15.1, \"Temperature\": 91.2 }] }]"
                                                     },
    "documentation_v10/Headers.html":  {
                                           "href":  "documentation_v10/Headers.html",
                                           "title":  "Message Headers | OSIsoft Message Format",
                                           "keywords":  "Message Headers The following headers are supported in version 1.0 of the message specification. Headers may be added or removed over time. Backwards compatibility is achievable through the omfversion header. Name Value producertoken A unique token used to identify and authorize a given OMF producer. Consult the OSIsoft Cloud Services or PI Connector Relay documentation for further information. messagetype Describes the type of message contained in the message body. One of: type , container , or data . See Message Types . messageformat Describes the data serialization format employed in the message body. Currently limited to json . omfversion Specifies the version of the OSIsoft Message Format used in the message. The version for this specification is 1.0. action Optional: One of: create , update , or delete . Describes the action to be performed using the data in the message body. If omitted, create is assumed. compression Optional: The compression algorithm used to compress the message body. Currently limited to gzip . If not specified, the message body is assumed to be uncompressed."
                                       },
    "documentation_v10/Message_Types.html":  {
                                                 "href":  "documentation_v10/Message_Types.html",
                                                 "title":  "Message Types | OSIsoft Message Format",
                                                 "keywords":  "Message Types OMF messages fall into three categories: Type, Container, and Data messages. Within each category, three types of actions can be specified: Create, Update, and Delete. Each message bulks individual JSON objects into a JSON array. Within a given array, all objects must be of the same message type: Type, Container, or Data. To achieve optimal throughput, bulking and compression of messages is recommended."
                                             },
    "documentation_v10/Types/Link_Type.html":  {
                                                   "href":  "documentation_v10/Types/Link_Type.html",
                                                   "title":  "Link Type | OSIsoft Message Format",
                                                   "keywords":  "Link Type A Link is a pre-defined type with the typeid __Link. It has the following properties. Name Value source An object representing the source of the link. target An object representing the target of the link. Each source and target object has the following keywords: Name Value typeid Optional id of the type. If omitted, containerid is expected. containerid Optional id of the container. If omitted, typeid is expected. typeversion Optional version of the type to be linked to or from. The version must be of format x.x.x.x, where x must be an integer greater than or equal to 0. If omitted version 1.0.0.0 is assumed. index Index of the data. If typeid is specified, index is mandatory. If containerid is specified it is optional. If typeid and index are specified, the link is for a particular non-container value. If containerid is specified with an index , the link is for a particular container value. If containerid is specified without an index , the link is for a container."
                                               },
    "documentation_v10/Types/Type_Messages.html":  {
                                                       "href":  "documentation_v10/Types/Type_Messages.html",
                                                       "title":  "Type Messages | OSIsoft Message Format",
                                                       "keywords":  "Type Messages Types are defined using the JSON Schema specification ( http://json-schema.org/ http:  json-schema.org  ). For details on supported property data types and formats, see Type Properties and Formats . Types can be created, updated, or deleted. Updating a Type without updating the Type\u0027s version will result in a failure. Once a Type is deleted, any operations on Containers or Data using that Type will fail. The body of a Type message consists of an array of objects. The following keywords are used to define a Type: Name Value id Unique identifier of the Type. classification One of dynamic or static . version Optional version of the Type. The version must be of format x.x.x.x, where x must be an integer greater than or equal to 0. If omitted version 1.0.0.0 is assumed. name Optional friendly name for the Type. description Optional description for the Type. tags Optional array of strings to tag the Type. metadata Optional key-value pairs associated with the Type. properties Key-value pairs defining the properties of a Type. type Inherited from JSON Schema. Must be set to object . The id cannot begin with the character sequence __. This has been reserved for predefined Types. Currently the only supported predefined Type is __Link . A static classification represents metadata describing a device being observed and should be used to capture data that is descriptive and relatively unchanging. A dynamic classification represents observed or calculated measurements taken from a device. Examples of Type Messages and Property Formats Link Type Type Properties and Formats Type Message Example"
                                                   },
    "documentation_v10/Types/Type_Msg_Example.html":  {
                                                          "href":  "documentation_v10/Types/Type_Msg_Example.html",
                                                          "title":  "Type Example | OSIsoft Message Format",
                                                          "keywords":  "Type Example Headers producertoken = b7CNvN36cq omfversion = 1.0 messagetype = type action = create messageformat = json Body [{ \"id\": \"Plant\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"static\", \"properties\": { \"PlantId\": { \"type\": \"string\", \"isindex\": true }, \"PlantName\": { \"type\": \"string\", \"isname\": true }, \"Address\": { \"type\": \"string\" }, \"Contact\": { \"type\": \"string\" } } }, { \"id\": \"Tank\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"static\", \"properties\": { \"TankName\": { \"type\": \"string\", \"isindex\": true, \"isname\": true }, \"Serial\": { \"type\": \"string\" }, \"Model\": { \"type\": \"string\" } } }, { \"id\": \"TankMeasurement\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"dynamic\", \"properties\": { \"Time\": { \"format\": \"date-time\", \"type\": \"string\", \"isindex\": true }, \"Pressure\": { \"type\": \"number\", \"name\": \"Tank Pressure\", \"description\": \"Tank Pressure in Pa\", \"uom\": \"pascal\" }, \"Temperature\": { \"type\": \"number\", \"name\": \"Tank Temperature\", \"description\": \"Tank Temperature in K\", \"uom\": \"K\" } } }, { \"id\": \"ComplexTank\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"static\", \"properties\": { \"Name\": { \"type\": \"string\", \"isindex\": true }, \"Dimensions\": { \"type\": \"object\", \"format\": \"dictionary\", \"additionalProperties\": { \"type\": \"number\", \"format\": \"float64\" } }, \"Maintenance Schedule\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"date-time\" } }, \"Location\": { \"type\": \"object\", \"properties\": { \"Latitude\": { \"type\": \"number\" }, \"Longitude\": { \"type\": \"number\" } } } } }]"
                                                      },
    "documentation_v10/Types/Type_Properties_and_Formats.html":  {
                                                                     "href":  "documentation_v10/Types/Type_Properties_and_Formats.html",
                                                                     "title":  "Type Properties and Formats | OSIsoft Message Format",
                                                                     "keywords":  "Type Properties and Formats The following keywords are used to define a Type Property: Name Value type Required type of the Type Property which must match a type listed in the Supported Formats table below. format Optional format of the type Property that, if specified, must be from the table below. isindex At least one Type Property must be designated as the index by supplying the isindex keyword with a value of true. The designated isindex property is used to uniquely identify discrete Data objects so that they can be updated or deleted after their initial creation. For a compound index, the order of index properties within the message determines the order within the index. isname One Type Property may be optionally designated as the name by supplying the isname keyword with a value of true. Because the index must be unique across all Data objects, the isname keyword allows for multiple distinct Data objects to share a common name. name Optional friendly name for the Type Property. description Optional description for the Type Property. OMF supports the array, boolean, integer, number, and string data types defined by JSON Schema. Timestamps, dictionaries, and bit length-specific numeric properties may also be defined by setting the format keyword, as described in the Supported Formats table below. Supported Formats Type Format Default Value Description array null An array of objects. The required items keyword defines the type of the objects in the array. boolean false A value of either \"true\" or \"false\". integer int64 0 64-bit integer. integer int32 (default) 0 32-bit integer. integer int16 0 16-bit integer. integer uint64 0 64-bit unsigned integer. integer uint32 0 32-bit unsigned integer. integer uint16 0 16-bit unsigned integer. number float64 0 64-bit floating point. number float32 (default) 0 32-bit floating point. number float16 0 16-bit floating point. object dictionary null A dictionary of objects, indexed by a string key. The additionalProperties keyword defines the dictionary\u0027s value type. string null A string. string date-time 0001-01-01T00:00:00Z A string representation of a timestamp, formatted as YYYY-MM-DDThh:mm:ssZ, with optional subsecond precision."
                                                                 },
    "documentation_v11/Containers/Container_Messages.html":  {
                                                                 "href":  "documentation_v11/Containers/Container_Messages.html",
                                                                 "title":  "Container Messages | OSIsoft Message Format",
                                                                 "keywords":  "Container Messages A Container is defined as a collection of Data events of identical Type and version. Each Container has a unique ID, defined upon creation of the Container. Once a Type has been registered with a Type message, Containers can begin using that Type. Containers can be created, updated, or deleted. The body of a Container message consists of an array of objects with the following keywords: Name Value id Unique identifier of the Container. typeid ID of the Type used by the Container. typeversion Optional version of the Type used by the Container. The version must be of format x.x.x.x, where x must be an integer greater than or equal to 0. If omitted, version 1.0.0.0 is used. name Optional friendly name for the Container. description Optional description for the Container. tags Optional array of strings to tag the Container. metadata Optional key-value pairs associated with the Container. indexes Optional array of Type Property ids to be used as secondary indexes for the Container. Example of Container Message Container Example"
                                                             },
    "documentation_v11/Containers/Container_Msg_Example.html":  {
                                                                    "href":  "documentation_v11/Containers/Container_Msg_Example.html",
                                                                    "title":  "Container Example | OSIsoft Message Format",
                                                                    "keywords":  "Container Example Headers producertoken = b7CNvN36cq omfversion = 1.1 messagetype = container action = create messageformat = json Body [{ \"id\": \"Tank1Measurements\", \"typeid\": \"TankMeasurement\", \"typeVersion\": \"1.0.0.0\", \"indexes\": [\"Pressure\"] }, { \"id\": \"Tank2Measurements\", \"typeid\": \"TankMeasurement\", \"typeVersion\": \"1.0.0.0\" }]"
                                                                },
    "documentation_v11/Data/Data_Messages.html":  {
                                                      "href":  "documentation_v11/Data/Data_Messages.html",
                                                      "title":  "Data Messages | OSIsoft Message Format",
                                                      "keywords":  "Data Messages Data messages can span multiple Types and Containers. The body of a Data message is composed of an array of objects with the following keywords: Name Value typeid Optional ID of the type. If omitted, container is expected. containerid Optional ID of the container. If omitted, type is expected. typeversion Optional version of the Type, if one is specified. The version must be of format x.x.x.x, where x must be an integer greater than or equal to 0. If omitted, version 1.0.0.0 is assumed. values An array of objects conforming to the type. For each object, either typeid or containerid must be specified. If containerid is specified, the values must conform to the Type with which the Container is associated. If typeid is specified, the values must conform to that Type. If a Type Property is defined but no property value is provided in the Data message, a default value will be assumed. Default values are specified in Type Properties and Formats . Example of Data Message Data Example"
                                                  },
    "documentation_v11/Data/Data_Msg_Example.html":  {
                                                         "href":  "documentation_v11/Data/Data_Msg_Example.html",
                                                         "title":  "Data Example | OSIsoft Message Format",
                                                         "keywords":  "Data Example Headers producertoken = b7CNvN36cq omfversion = 1.1 messagetype = data action = create messageformat = json Body [{ \"typeid\": \"Plant\", \"values\": [{ \"PlantId\": \"PlantId1\", \"PlantName\": \"Plant1\", \"Address\": \"123 Meridian Ave\", \"Contact\": \"Bob Ross\" }] }, { \"typeid\": \"Tank\", \"values\": [{ \"TankName\": \"Tank1\", \"Serial\": \"5236-3523-KKF4\", \"Model\": \"FN-2187\" }, { \"TankName\": \"Tank2\", \"Serial\": \"2364-4243-FS12\", \"Model\": \"TK-421\" }] }, { \"typeid\": \"__Link\", \"values\": [{ \"source\": { \"typeid\": \"Plant\", \"index\": \"PlantId1\" }, \"target\": { \"typeid\": \"Tank\", \"index\": \"Tank1\" } }, { \"source\": { \"typeid\": \"Plant\", \"index\": \"PlantId1\" }, \"target\": { \"typeid\": \"Tank\", \"index\": \"Tank2\" } }, { \"source\": { \"typeid\": \"Tank\", \"index\": \"Tank1\" }, \"target\": { \"containerid\": \"Tank1Measurements\" } }, { \"source\": { \"typeid\": \"Tank\", \"index\": \"Tank2\" }, \"target\": { \"containerid\": \"Tank2Measurements\" } }] }, { \"containerid\": \"Tank1Measurements\", \"values\": [{ \"Time\": \"2017-01-11T22:23:23.430Z\", \"Pressure\": 12.0, \"Temperature\": 100.1 }, { \"Time\": \"2017-01-11T22:24:23.430Z\", \"Pressure\": 11.5, \"Temperature\": 101.2 }] }, { \"containerid\": \"Tank2Measurements\", \"values\": [{ \"Time\": \"2017-01-11T22:23:23.430Z\", \"Pressure\": 14.0, \"Temperature\": 90.1 }, { \"Time\": \"2017-01-11T22:24:23.430Z\", \"Pressure\": 15.1, \"Temperature\": 91.2 }] }]"
                                                     },
    "documentation_v11/Headers.html":  {
                                           "href":  "documentation_v11/Headers.html",
                                           "title":  "Message Headers | OSIsoft Message Format",
                                           "keywords":  "Message Headers The following headers are supported in version 1.1 of the message specification. Headers may be added or removed over time. Backwards compatibility is achievable through the omfversion header. Name Value producertoken A unique token used to identify and authorize a given OMF producer. Consult the OSIsoft Cloud Services or PI Connector Relay documentation for further information. messagetype Describes the type of message contained in the message body. One of: type , container , or data . See Message Types . messageformat Describes the data serialization format employed in the message body. Currently limited to json . omfversion Specifies the version of the OSIsoft Message Format used in the message. The version for this specification is 1.1. action Optional: One of: create , update , or delete . Describes the action to be performed using the data in the message body. If omitted, create is assumed. compression Optional: The compression algorithm used to compress the message body. Currently limited to gzip . If not specified, the message body is assumed to be uncompressed."
                                       },
    "documentation_v11/Message_Types.html":  {
                                                 "href":  "documentation_v11/Message_Types.html",
                                                 "title":  "Message Types | OSIsoft Message Format",
                                                 "keywords":  "Message Types OMF messages fall into three categories: Type, Container, and Data messages. Within each category, three types of actions can be specified: Create, Update, and Delete. Each message bulks individual JSON objects into a JSON array. Within a given array, all objects must be of the same message type: Type, Container, or Data. To achieve optimal throughput, bulking and compression of messages is recommended."
                                             },
    "documentation_v11/Types/Link_Type.html":  {
                                                   "href":  "documentation_v11/Types/Link_Type.html",
                                                   "title":  "Link Type | OSIsoft Message Format",
                                                   "keywords":  "Link Type A Link is a pre-defined type with the typeid __Link. It has the following properties. Name Value source An object representing the source of the link. target An object representing the target of the link. Each source and target object has the following keywords: Name Value typeid Optional id of the type. If omitted, containerid is expected. containerid Optional id of the container. If omitted, typeid is expected. typeversion Optional version of the type to be linked to or from. The version must be of format x.x.x.x, where x must be an integer greater than or equal to 0. If omitted version 1.0.0.0 is assumed. index Index of the data. If typeid is specified, index is mandatory. If containerid is specified, it is optional. If typeid and index are specified, the link is for a particular non-container value. If containerid is specified with an index , the link is for a particular container value. If containerid is specified without an index , the link is for a container."
                                               },
    "documentation_v11/Types/Type_Messages.html":  {
                                                       "href":  "documentation_v11/Types/Type_Messages.html",
                                                       "title":  "Type Messages | OSIsoft Message Format",
                                                       "keywords":  "Type Messages Types are defined using the JSON Schema specification ( http://json-schema.org/ http:  json-schema.org  ). For details on supported property data types and formats, see Type Properties and Formats . Types can be created, updated, or deleted. Updating a Type without updating the Type\u0027s version will result in a failure. Once a Type is deleted, any operations on Containers or Data using that Type will fail. The body of a Type message consists of an array of objects. The following keywords are used to define a Type: Name Value id Unique identifier of the Type. classification One of dynamic or static . version Optional version of the Type. The version must be of format x.x.x.x, where x must be an integer greater than or equal to 0. If omitted version 1.0.0.0 is assumed. name Optional friendly name for the Type. description Optional description for the Type. tags Optional array of strings to tag the Type. metadata Optional key-value pairs associated with the Type. properties Key-value pairs defining the properties of a Type. type Inherited from JSON Schema. Must be set to object . The id cannot begin with the character sequence __. This has been reserved for predefined Types. Currently the only supported predefined Type is __Link . A static classification represents metadata describing a device being observed and should be used to capture data that is descriptive and relatively unchanging. A dynamic classification represents observed or calculated measurements taken from a device. Examples of Type Messages and Property Formats Link Type Type Properties and Formats Type Message Example"
                                                   },
    "documentation_v11/Types/Type_Msg_Example.html":  {
                                                          "href":  "documentation_v11/Types/Type_Msg_Example.html",
                                                          "title":  "Type Example | OSIsoft Message Format",
                                                          "keywords":  "Type Example Headers producertoken = b7CNvN36cq omfversion = 1.1 messagetype = type action = create messageformat = json Body [{ \"id\": \"Plant\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"static\", \"properties\": { \"PlantId\": { \"type\": \"string\", \"isindex\": true }, \"PlantName\": { \"type\": \"string\", \"isname\": true }, \"Address\": { \"type\": \"string\" }, \"Contact\": { \"type\": \"string\" } } }, { \"id\": \"Tank\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"static\", \"properties\": { \"TankName\": { \"type\": \"string\", \"isindex\": true, \"isname\": true }, \"Serial\": { \"type\": \"string\" }, \"Model\": { \"type\": \"string\" } } }, { \"id\": \"TankMeasurement\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"dynamic\", \"properties\": { \"Time\": { \"format\": \"date-time\", \"type\": \"string\", \"isindex\": true }, \"Pressure\": { \"type\": \"number\", \"name\": \"Tank Pressure\", \"description\": \"Tank Pressure in Pa\", \"uom\": \"pascal\" }, \"Temperature\": { \"type\": \"number\", \"name\": \"Tank Temperature\", \"description\": \"Tank Temperature in K\", \"uom\": \"K\" } } }, { \"id\": \"TankV2\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"static\", \"properties\": { \"Name\": { \"type\": \"string\", \"isindex\": true }, \"Dimensions\": { \"type\": \"object\", \"format\": \"dictionary\", \"additionalProperties\": { \"type\": \"number\", \"format\": \"float64\" } }, \"Maintenance Schedule\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"date-time\" } }, \"Location\": { \"type\": \"object\", \"properties\": { \"Latitude\": { \"type\": \"number\" }, \"Longitude\": { \"type\": \"number\" } } } } }]"
                                                      },
    "documentation_v11/Types/Type_Properties_and_Formats.html":  {
                                                                     "href":  "documentation_v11/Types/Type_Properties_and_Formats.html",
                                                                     "title":  "Type Properties and Formats | OSIsoft Message Format",
                                                                     "keywords":  "Type Properties and Formats The following keywords are used to define a Type Property: Name Value type Required type of the Type Property which must match a type listed in the Supported Formats table below. format Optional format of the type Property that, if specified, must be from the table below. isindex At least one Type Property must be designated as the index by supplying the isindex keyword with a value of true. The designated isindex property is used to uniquely identify discrete Data objects so that they can be updated or deleted after their initial creation. For a compound index, the order of index properties within the message determines the order within the index. isname One Type Property may be optionally designated as the name by supplying the isname keyword with a value of true. Because the index must be unique across all Data objects, the isname keyword allows for multiple distinct Data objects to share a common name. name Optional friendly name for the Type Property. description Optional description for the Type Property. uom Optional unit of measure for the Type Property. OMF supports the array, boolean, integer, number, and string data types defined by JSON Schema. Timestamps, dictionaries, and bit length-specific numeric properties may also be defined by setting the format keyword, as described in the Supported Formats table below. Supported Formats Type Format Default Value Description array null An array of objects. The required items keyword defines the type of the objects in the array. boolean false A value of either \"true\" or \"false\". integer int64 0 64-bit integer. integer int32 (default) 0 32-bit integer. integer int16 0 16-bit integer. integer uint64 0 64-bit unsigned integer. integer uint32 0 32-bit unsigned integer. integer uint16 0 16-bit unsigned integer. number float64 0 64-bit floating point. number float32 (default) 0 32-bit floating point. number float16 0 16-bit floating point. object dictionary null A dictionary of objects, indexed by a string key. The additionalProperties keyword defines the dictionary\u0027s value type. string null A string. string date-time 0001-01-01T00:00:00Z A string representation of a timestamp, formatted as YYYY-MM-DDThh:mm:ssZ, with optional subsecond precision. Nullable type properties Nullable type properties are supported by specifying an array that defines the datatype and includes the keyword null . The datatype and null may appear in any order in the array. For example: \"MeasurementValue\": {\"type\": [\"integer\", \"null\"], \"format\": \"int64\"} \"MeasurementValue\": {\"type\": [\"null\", \"integer\"], \"format\": \"int64\"}"
                                                                 },
    "documentation_v11/Whats_New.html":  {
                                             "href":  "documentation_v11/Whats_New.html",
                                             "title":  "What\u0027s New | OSIsoft Message Format",
                                             "keywords":  "What\u0027s New Version 1.1 introduces the following incremental changes from version 1.0: Enhancements for Type messages: Nullable Type properties which can be declared by specifying an array of accepted values, including the type and null . A uom keyword for Type properties representing the optional unit of measure. Enhancements for Container messages: An indexes keyword for Container messages representing the optional array of Type Property ids to be used as secondary indexes for the Container."
                                         },
    "documentation_v12/Containers/Container_Messages.html":  {
                                                                 "href":  "documentation_v12/Containers/Container_Messages.html",
                                                                 "title":  "Container Messages | OSIsoft Message Format",
                                                                 "keywords":  "Container Messages A Container can be defined for Types whose classification is dynamic , and provides a stream of data events. Each Container has a unique ID defined by the user. Immediately after a Type has been registered using a Type message, Containers may be created using that Type. Containers support the same set of actions defined for Type messsages: create , update , and delete . The body of a Container message consists of an array of objects with the following keywords: Name Value id Unique identifier of the Container. typeid ID of the Type used by the Container. name Optional friendly name for the Container. description Optional description for the Container. datasource Optional string used to specify the source of a stream of data. tags Optional array of strings to tag the Container. metadata Optional key-value pairs associated with the Container. indexes Optional array of Type Property ids to be used as secondary indexes for the Container. propertyoverrides Optional key-value pairs used to override properties on a Type definition. Certain keywords defined on Type properties may be overridden at the container level using the optional propertyoverrides keyword. Currently supported overrides include name , description , uom , minimum , and maximum . Refer to the Type Properties and Formats for a complete list of Type properties . Container Example Container Example"
                                                             },
    "documentation_v12/Containers/Container_Msg_Example.html":  {
                                                                    "href":  "documentation_v12/Containers/Container_Msg_Example.html",
                                                                    "title":  "Container Example | OSIsoft Message Format",
                                                                    "keywords":  "Container Example Headers omfversion = 1.2 messagetype = container action = create messageformat = json Body [{ \"id\": \"Tank1_PressureMeasurements\", \"typeid\": \"TankPressure\", \"datasource\":\"Modbus\", \"indexes\": [\"Pressure\"] }, { \"id\": \"Tank2_PressureMeasurements\", \"typeid\": \"TankPressure\", \"datasource\":\"Modbus\", \"indexes\": [\"Pressure\"], \"propertyoverrides\": { \"Pressure\": { \"minimum\": 15, \"maximum\": 30 } } }]"
                                                                },
    "documentation_v12/Data/Data_Messages.html":  {
                                                      "href":  "documentation_v12/Data/Data_Messages.html",
                                                      "title":  "Data Messages | OSIsoft Message Format",
                                                      "keywords":  "Data Messages Data messages can be used to create instance data for previously defined Types and Containers, relate instances of static and dynamic data, relate Types, or send type-less static data. The body of a Data message is composed of a JSON array with JSON objects defined by the following keywords: Name Value typeid Optional ID of the type. If omitted, container or properties is expected. containerid Optional ID of the container. If omitted, type or properties is expected. properties Optional key-value pairs defining the properties of the Type. Used to support sending type-less static data values. values An array of objects conforming to the type. For a data message, either the id of a previously defined type or container must be specified, or the data messages must be used to send type-less static data and specify the properties . If typeid is specified, the values array must conform to the definition of that Type. If containerid is specified, the values must conform to the Type associated with the Container. If properties is specified, then the data message can be used to send static data for an instance that has no Type. Optionally a typeid may be specified along with the properties to extend a static Type with additional properties. If a property is defined on the Type definition, and that property is not included in the values array, then a default value for that property will be assumed. Default values are specified in the Supported Formats Table. Link Data Messages __Link Data messages are used to create relationships between static Types, static and dynamic Types, and instance Data. To define a link relationship, set the typeid of the data message to __Link , and in the values array specify the source and target of the link relationship. Refer to Link Type for detailed information on defining links in data messages to relate data. Examples of Data Messages Link Type Data Example"
                                                  },
    "documentation_v12/Data/Data_Msg_Example.html":  {
                                                         "href":  "documentation_v12/Data/Data_Msg_Example.html",
                                                         "title":  "Data Example | OSIsoft Message Format",
                                                         "keywords":  "Data Example In this example, instance data is created for the static types \u0027Plant\u0027 and \u0027Tank\u0027, and the dynamic type, \u0027TankPressure\u0027, for Containers \u0027Tank1_PressureMeasurements\u0027 and \u0027Tank2_PressureMeasurements\u0027. The link data messages are used to relate the instance data as well as combine static and dynamic Types. Headers omfversion = 1.2 messagetype = data action = create messageformat = json Body [{ \"typeid\": \"Plant\", \"values\": [{ \"PlantId\": \"WTP1\", \"PlantName\": \"Water Treatment Plant One\", \"Address\": \"123 Meridian Ave\", \"Contact\": \"Bob Ross\" }] }, { \"typeid\": \"Tank\", \"values\": [{ \"TankName\": \"Tank1\", \"Serial\": \"5236-3523-KKF4\", \"Model\": \"FN-2187\" }, { \"TankName\": \"Tank2\", \"Serial\": \"2364-4243-FS12\", \"Model\": \"TK-421\" }] }, { \"typeid\": \"__Link\", \"values\": [{ \"source\": { \"typeid\": \"Plant\", \"index\": \"WTP1\" }, \"target\": { \"typeid\": \"Tank\", \"index\": \"Tank1\" } }, { \"source\": { \"typeid\": \"Plant\", \"index\": \"WTP1\" }, \"target\": { \"typeid\": \"Tank\", \"index\": \"Tank2\" } }, { \"source\": { \"typeid\": \"Tank\", \"index\": \"Tank1\" }, \"target\": { \"containerid\": \"Tank1_PressureMeasurements\" } }, { \"source\": { \"typeid\": \"Tank\", \"index\": \"Tank2\" }, \"target\": { \"containerid\": \"Tank2_PressureMeasurements\" } }] }, { \"containerid\": \"Tank1_PressureMeasurements\", \"values\": [{ \"Time\": \"2019-09-11T22:23:23.430Z\", \"Pressure\": 12.0 }, { \"Time\": \"2019-09-11T22:24:23.430Z\", \"Pressure\": 11.5 }] }, { \"containerid\": \"Tank2_PressureMeasurements\", \"values\": [{ \"Time\": \"2019-09-11T22:23:23.430Z\", \"Pressure\": 14.0 }, { \"Time\": \"2019-09-11T22:24:23.430Z\", \"Pressure\": 15.1 }] }] Inheritance Data Message Example In this example, the Data message contains values for the inherited properties TankName, Serial and Model as well as the properties TankHeight and TankWidth. { \"typeid\":\"RectangularTank\", \"values\": [{ \"TankName\": \"RectangularTank1\", \"Serial\":\"3829-3827-C0EK\", \"Model\":\"EL-5839\", \"TankHeight\": 120, \"TankWidth\": 90 }] } Reference Data Message Example In this example, the Data message contains values Latitude and Longitude which were included using reftypeid on the Location property. { \"typeid\":\"TankV2\", \"values\": [{ \"TankName\": \"Tank3\", \"Serial\": \"1928-4827-2987\", \"Model\": \"KE-2834\", \"Location\": { \"Latitude\": 36.3134, \"Longitude\": -82.3535 } }] } Enum Data Message Example In this example, the Data message contains values for the ValvePosition and DeviceStatus. These properties were defined as enum types using reftypeid . { \"containerid\":\"TankMeasurementsV1_Tank3\", \"values\": [{ \"Time\": \"2019-09-11T22:23:23.430Z\", \"DeviceStatus\": 2, \"ValvePosition\": 1, \"Pressure\": 16.0, \"Temperature\": 90.1 }] } Type-less Static Data Message In this example, the Data message extends the \u0027Tank\u0027 type to include a \u0027Maintenance Schedule\u0027 for this instance. The \u0027Tank\u0027 Type itself is not extended. [{ \"typeid\": \"Tank\", \"properties\": { \"Maintenance Schedule\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"date-time\" } } }, \"values\": [{ \"TankName\": \"Tank1\", \"Serial\": \"5236-3523-KKF4\", \"Model\": \"FN-2187\", \"Maintenance Schedule\": [ \"2019-09-01T00:00:00Z\", \"2019-09-01T08:00:00Z\", \"2019-09-01T16:00:00Z\" ] }] }] In this example, the Data message defines properties for a Tank, and sends the instance data. No Type definitions are defined or created. [{ \"properties\": { \"Name\": { \"type\":\"string\", \"isindex\":true }, \"Description\": { \"type\":\"string\" }, \"Model\": { \"type\":\"string\" }, \"HourlyMaintenanceSchedule\": { \"type\": \"integer\", \"format\": \"int16\" } }, \"values\": [{ \"Name\": \"Tank4\", \"Description\": \"Tank4 in Building C12\", \"Model\": \"EK-2393\", \"HourlyMaintenanceSchedule\": 8 }] }]"
                                                     },
    "documentation_v12/Data/Link_Type.html":  {
                                                  "href":  "documentation_v12/Data/Link_Type.html",
                                                  "title":  "Link Data Messages | OSIsoft Message Format",
                                                  "keywords":  "Link Data Messages A Link is used to create relationships between Types and instances of Types, and is defined using the pre-defined typeid __Link in the Data Message. The values array in the Data message contains the following properties: Name Value source An object representing the source of the link. target An object representing the target of the link. Each source and target object has the following keywords: Name Value typeid Optional id of the type. If omitted, containerid is expected. containerid Optional id of the container. If omitted, typeid is expected. index Value of the isindex Type Properties and Formats property defined when creating the instance of a Type. If typeid is specified, index is required. If containerid is specified, index is not supported. property Optional name of a property defined in the Type definition to be used by the link relationship. To relate instances of data specify the following options. For an instance of a Type, specify the typeid and index of the instance. For an instance of a Container, specify the containerid . Link Examples for Instance Data For example, to relate an instance of a Plant, specified by its indexed property PlantId with value WTP1, to an instance of Tank, specified with by its indexed property TankName with value Tank1, use the following __Link : [{ \"typeid\": \"Plant\", \"values\": [{ \"PlantId\": \"WTP1\", \"PlantName\": \"Water Treatment Plant One\" }] }, { \"typeid\": \"Tank\", \"values\": [{ \"TankName\": \"Tank1\" }] }, { \"typeid\": \"__Link\", \"values\": [ { \"source\": { \"typeid\": \"Plant\", \"index\": \"WTP1\" }, \"target\": { \"typeid\": \"Tank\", \"index\": \"Tank1\" } }] }] To associate the container, Tank1Measurements, with the instance of a Tank whose index is \u0027Tank1\u0027, use the following __Link : [{ \"typeid\": \"__Link\", \"values\": [{ \"source\": { \"typeid\": \"Tank\", \"index\": \"Tank1\" }, \"target\": { \"containerid\": \"Tank1Measurements\" } }] }] Link Examples for Instance Data for Properties To associate instances of Types and Containers at the Property level, define the property in the Link relationship. This expands the static Type \u0027Pump\u0027 to include the properties InletFlow and OutletFlow, and creates a link between the instance data for Pump1 and Pump1InletFlowMeasurements. [{ \"typeid\": \"__Link\", \"values\": [{ \"source\": { \"typeid\": \"Pump\", \"index\": \"Pump1\", \"property\": \"InletFlow\" }, { \"target\": { \"containerid\": \"Pump1InletFlowMeasurements\" } }, { \"source\": { \"typeid\": \"Pump\", \"index\": \"Pump1\", \"property\": \"OutletFlow\" }, { \"target\": { \"containerid\": \"Pump1OutletFlowMeasurements\" } }] To associate instances of Types and Containers at the Property level, and include only specific properties within the Types, define the property in the Link relationship. This expands the static Type \u0027Pump\u0027 to include the property InletFlowTemperature, and creates a link between the instance data for Pump1 and the Temperature property from the Pump1InletFlowMeasurements container. Similarly, the InletFlowPressue property is created on the Pump, and Pump1 InletFlowPressue property is linked withe Pressure property in the Pump1InletFlowMeasurements container. [{ \"typeid\": \"__Link\", \"values\": [{ \"source\": { \"typeid\": \"Pump\", \"index\": \"Pump1\", \"property\": \"InletFlowTemperature\" }, { \"target\": { \"containerid\": \"Pump1InletFlowMeasurements\", \"property\": \"Temperature\" } }, { \"source\": { \"typeid\": \"Pump\", \"index\": \"Pump1\", \"property\": \"InletFlowPressure\" }, { \"target\": { \"containerid\": \" Pump1InletFlowMeasurements\", \"property\": \"Pressure\" } }] }] Link Examples for Types and Properties To associate Types and Containers at the Property level, define the property in the Link relationship. This expands the static Type \u0027Pump\u0027 to include the properties InletFlow and OutletFlow, and applies the definition of FlowMeasurements for the properties. [{ \"typeid\": \"__Link\", \"values\": [{ \"source\": { \"typeid\": \"Pump\", \"property\": \"InletFlow\" }, { \"target\": { \"typeid\": \"FlowMeasurements\" } }, { \"source\": { \"typeid\": \"Pump\", \"property\": \"OutletFlow\" }, { \"target\": { \"typeid\": \"FlowMeasurements\" } }] }] To associate Types and Containers at the Property level, and include only specific properties within the Types, define the property in the Link relationship. This expands the static Type \u0027Pump\u0027 to include the property InletFlowTemperature and InletFlowPressue, and applies the definition of the Pressure property in FlowMeasurements to the InletFlowPressure, and the Temperature property as the type for the InletFlowTemperature. [{ \"typeid\": \"__Link\", \"values\": [{ \"source\": { \"typeid\": \"Pump\", \"property\": \"InletFlowTemperature\" }, { \"target\": { \"typeid\": \"FlowMeasurements\", \"property\": \"Temperature\" } }, { \"source\": { \"typeid\": \"Pump\", \"property\": \"InletFlowPressure\" }, { \"target\": { \"typeid\": \"FlowMeasurements\", \"property\": \"Pressure\" } }] }]"
                                              },
    "documentation_v12/Headers.html":  {
                                           "href":  "documentation_v12/Headers.html",
                                           "title":  "Message Headers | OSIsoft Message Format",
                                           "keywords":  "Message Headers The following headers are supported in version 1.2 of the message specification. Headers may be added or removed over time. Backwards compatibility is achievable through the omfversion header. Name Value messagetype Describes the type of message contained in the message body. One of: type , container , or data . See Message Types . messageformat Describes the data serialization format employed in the message body. Currently limited to json . omfversion Specifies the version of the OSIsoft Message Format used in the message. The version for the current specification is 1.2. action Optional: One of: create , update , or delete . Describes the action to be performed using the data in the message body. If omitted, create is assumed. compression Optional: The compression algorithm used to compress the message body. Currently limited to gzip . If not specified, the message body is assumed to be uncompressed."
                                       },
    "documentation_v12/Message_Types.html":  {
                                                 "href":  "documentation_v12/Message_Types.html",
                                                 "title":  "Message Types | OSIsoft Message Format",
                                                 "keywords":  "Message Types Messages are defined based on the concepts in the JSON Schema specification ( http://json-schema.org/ http:  json-schema.org  ). Each message is a JSON Array containing one or more JSON objects. The OMF messagetype specified in the message header describes the type of data in the JSON array. The messagetype must be set to one of the following categories: type , container , or data . Refer to the following topics for detailed information on the supported formats of each messagetype : Type Container Data For each OMF messagetype , the action to take on the message body is one of create , update , or delete . If not explicitly set then the action will default to create . For a complete working example of Type, Container and Data messages refer to the following example: OMF v1.2 Example To achieve optimal throughput, include multiple messages of the same messagetype within the JSON array, and apply compression to the message body as described in the Message Headers Topic."
                                             },
    "documentation_v12/OMF_Msg_Sample.html":  {
                                                  "href":  "documentation_v12/OMF_Msg_Sample.html",
                                                  "title":  "OMF v1.2 Example | OSIsoft Message Format",
                                                  "keywords":  "OMF v1.2 Example Example for creating Types, Containers and Data for static and dynamic data. The example shows how to setup a static Type and define the index and name properties, and shows how to setup a dynamic Type for the frequently changing data. Next Containers are created for the dynamic Types to provide streams for data events. Lastly, data messages are used to create instances of static types, relate static and dynamic data, and send data values. Type Message Headers omfversion = 1.2 messagetype = type action = create messageformat = json Type Message Body [{ \"id\": \"Plant\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"static\", \"properties\": { \"PlantId\": { \"type\": \"string\", \"isindex\": true }, \"PlantName\": { \"type\": \"string\", \"isname\": true }, \"Address\": { \"type\": \"string\" }, \"Contact\": { \"type\": \"string\" } } }{ \"id\": \"TankMeasurement\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"dynamic\", \"properties\": { \"Pressure\": { \"type\": \"number\", \"name\": \"Tank Pressure\", \"description\": \"Tank Pressure in Pa\", \"uom\": \"pascal\", \"interpolation\": \"Continuous\", \"extrapolation\": \"Forward\", \"max\": \"20\", \"min\": \"10\" }, \"Temperature\": { \"type\": \"number\", \"name\": \"Tank Temperature\", \"description\": \"Tank Temperature in K\", \"uom\": \"K\" }, \"Timestamp\": { \"type\": \"string\", \"format\":\"date-time\", \"isindex\": true } } },{ \"id\":\"LocationProperties\", \"type\":\"object\", \"properties\": { \"Latitude\":{ \"type\":\"number\", \"format\":\"float32\" }, \"Longitude\":{ \"type\":\"number\", \"format\":\"float32\" } } },{ \"id\": \"TankV2\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"static\", \"properties\": { \"TankName\": { \"type\": \"string\", \"isname\": true, \"isindex\":true }, \"Serial\": { \"type\": \"string\" }, \"Model\": { \"type\": \"string\" }, \"Location\": { \"reftypeid\": \"LocationProperties\" } } }, { \"id\":\"RectangularTank\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"static\", \"basetypeid\": \"TankV2\", \"properties\": { \"TankHeight\": { \"type\": \"integer\", \"format\":\"int32\", \"uom\":\"ft\" }, \"TankWidth\": { \"type\": \"integer\", \"format\":\"int32\", \"uom\":\"ft\" } } }] Create containers for the dynamic types. Container Message Headers omfversion = 1.2 messagetype = container action = create messageformat = json Container Message Body [{ \"id\": \"Tank1Measurements\", \"typeid\": \"TankMeasurement\", \"indexes\": [\"Pressure\"], \"datasource\":\"Modbus\" }, { \"id\": \"Tank2Measurements\", \"typeid\": \"TankMeasurement\", \"datasource\":\"Modbus\", \"propertyoverrides\": { \"Temperature\": { \"description\": \"Tank Temperature in degree Fahrenheit\", \"uom\": \"F\" } } }, { \"id\": \"Tank_R1_Measurements\", \"typeid\": \"TankMeasurement\", \"datasource\":\"Modbus\" }] Send data messages to create assets, relate instances, and send data values, for static, dynamic and type-less data instances. Data Message Headers omfversion = 1.2 messagetype = data action = create messageformat = json Data Message Body [{ \"typeid\": \"Plant\", \"values\": [{ \"PlantId\": \"WTP1\", \"PlantName\": \"Water Treatment Plant One\", \"Address\": \"123 Meridian Ave\", \"Contact\": \"Bob Ross\" }] }, { \"typeid\": \"TankV2\", \"values\": [{ \"TankName\": \"Tank1\", \"Serial\": \"5236-3523-KKF4\", \"Model\": \"FN-2187\", \"Location\": { \"Latitude\": 36.3134, \"Longitude\": -82.3535 } }, { \"TankName\": \"Tank2\", \"Serial\": \"2364-4243-FS12\", \"Model\": \"TK-421\" , \"Location\": { \"Latitude\": 45.4046, \"Longitude\": -122.579 } }] }, { \"typeid\": \"RectangularTank\", \"values\": [{ \"TankName\": \"Tank_R1\", \"Serial\": \"4738-9283-CKD4\", \"Model\": \"SD-3947\", \"Location\": { \"Latitude\": 52.273, \"Longitude\": -95.2834 }, \"TankHeight\": 100, \"TankWidth\": 80 }] }, { \"properties\": { \"Name\": { \"type\":\"string\", \"isindex\":true }, \"Description\": { \"type\":\"string\" }, \"Model\": { \"type\":\"string\" }, \"HourlyMaintenanceSchedule\": { \"type\": \"integer\", \"format\": \"int16\" } }, \"values\": [{ \"Name\": \"Tank4\", \"Description\": \"Tank4 in Building C12\", \"Model\": \"EK-2393\", \"HourlyMaintenanceSchedule\": 8 }] }, { \"typeid\": \"__Link\", \"values\": [{ \"source\": { \"typeid\": \"Plant\", \"index\": \"WTP1\" }, \"target\": { \"typeid\": \"TankV2\", \"index\": \"Tank1\" } }, { \"source\": { \"typeid\": \"Plant\", \"index\": \"WTP1\" }, \"target\": { \"typeid\": \"TankV2\", \"index\": \"Tank2\" } }, { \"source\": { \"typeid\": \"Plant\", \"index\": \"WTP1\" }, \"target\": { \"typeid\": \"RectangularTank\", \"index\": \"Tank_R1\" } }, { \"source\": { \"typeid\": \"TankV2\", \"index\": \"Tank1\" }, \"target\": { \"containerid\": \"Tank1Measurements\" } }, { \"source\": { \"typeid\": \"TankV2\", \"index\": \"Tank2\" }, \"target\": { \"containerid\": \"Tank2Measurements\" } }, { \"source\": { \"typeid\": \"RectangularTank\", \"index\": \"Tank_R1\" }, \"target\": { \"containerid\": \"Tank_R1_Measurements\" } }] }, { \"containerid\": \"Tank1Measurements\", \"values\": [{ \"Time\": \"2019-09-11T22:23:23.430Z\", \"Pressure\": 12.0, \"Temperature\": 100.1 }, { \"Time\": \"2019-09-11T22:24:23.430Z\", \"Pressure\": 11.5, \"Temperature\": 101.2 }] }, { \"containerid\": \"Tank2Measurements\", \"values\": [{ \"Time\": \"2019-09-11T22:23:23.430Z\", \"Pressure\": 14.0, \"Temperature\": 90.1 }, { \"Time\": \"2019-09-11T22:24:23.430Z\", \"Pressure\": 15.1, \"Temperature\": 91.2 }] }, { \"containerid\": \"Tank_R1_Measurements\", \"values\": [{ \"Time\": \"2019-09-11T22:23:23.430Z\", \"Pressure\": 13.0, \"Temperature\": 93.5 }, { \"Time\": \"2019-09-11T22:24:23.430Z\", \"Pressure\": 12.6, \"Temperature\": 97.1 }] }]"
                                              },
    "documentation_v12/Types/Enum_Type.html":  {
                                                   "href":  "documentation_v12/Types/Enum_Type.html",
                                                   "title":  "Enum Type Messages | OSIsoft Message Format",
                                                   "keywords":  "Enum Type Messages An enum is a Type message defined using an array of name/value name value pairs used to create a limited set of allowed values. Once defined, the enum can be referenced by Properties within other Type messages. An enum can also be used to define a a set of Data Quality values. When defining data quality include the quality property in the enum definition, and denote the quality as good , bad , or questionable . To define an enum Type, include the following keywords. If a keyword is not specified, then the default value will be used. Name Value name A unique string that describes the condition or state being represented. This string is used as the displayed value when an enum is selected as the Type for a property. value Optional integer value associated with the enum. If not defined the enum ranges from 0 to one less than size of the collection. The integer value is typically used when sending data of this type. quality Optional field needed when defining a set of data quality values. Must be set to good , bad , or questionable . Defaults to \u0027good\u0027 when not specified. The enum definition could contain only the name property and accept the defaults for the other properties, or explicitly define all the properties. For example a Valve could have 2 states, CLOSED or OPEN and accept the defaults, or explicitly define the values. The following Type messages are valid syntax: { \"id\": \"ValveState\", \"enum\":[ \"CLOSED\", \"OPEN\"] } { \"id\": \"ValveState\", \"enum\": [ {\"name\":\"CLOSED\", \"value\":0}, {\"name\":\"OPEN\", \"value\":1} ] } { \"id\": \"ValveState\", \"enum\":[ {\"value\":0, \"name\":\"CLOSED\" }, {\"value\":1, \"name\":\"OPEN\"} ] } Enum Type Messages for Data Quality The following Type message defines a data quality enum . An enum could be used to define a set of allowed values that represents data quality. In this case include the quality in the enum definition. If quality is not explicitly set then it is assumed to be \u0027good\u0027. { \"id\": \"DeviceStatusEnum\", \"enum\":[ { \"name\": \"Device Connected\", \"value\": 0 }, { \"name\": \"Device Failure\", \"value\": 1, \"quality\": \"bad\" }, { \"name\": \"Device Comm Failure\", \"value\": 2, \"quality\": \"bad\" }, { \"name\": \"Uncertain - Out Limits\", \"value\": 3, \"quality\": \"questionable\" } ] } When referencing the enum from the property that holds quality, include the isquality keyword and use reftypeid as the data type of the property: { \"DeviceStatus\": { \"reftypeid\": \"DeviceStatusEnum\", \"isquality\": true } } Examples [{ \"id\": \"ValveState\", \"version\": \"1.0.0.0\", \"enum\": [ {\"name\":\"CLOSED\", \"value\":0}, {\"name\":\"OPEN\", \"value\":1} ] }, { \"id\": \"DeviceStatusEnum\", \"enum\":[ { \"name\": \"Device Connected\", \"value\": 0, \"quality\": \"good\" }, { \"name\": \"Device Failure\", \"value\": 1, \"quality\": \"bad\" }, { \"name\": \"Device Comm Failure\", \"value\": 2, \"quality\": \"bad\" }, { \"name\": \"Uncertain - Out Limits\", \"value\": 3, \"quality\": \"questionable\" } ] }, { \"id\": \"TankMeasurementV1\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"dynamic\", \"properties\": { \"Timestamp\": { \"type\": \"string\", \"format\":\"date-time\", \"isindex\": true }, \"DeviceStatus\": { \"reftypeid\": \"DeviceStatusEnum\", \"isquality\": true }, \"ValvePosition\": { \"reftypeid\": \"ValveState\" }, \"Pressure\": { \"type\": \"number\", \"name\": \"Tank Pressure\", \"description\": \"Tank Pressure in Pa\", \"uom\": \"pascal\" }, \"Temperature\": { \"type\": \"number\", \"name\": \"Tank Temperature\", \"description\": \"Tank Temperature in K\", \"uom\": \"K\" } } }]"
                                               },
    "documentation_v12/Types/Type_Messages.html":  {
                                                       "href":  "documentation_v12/Types/Type_Messages.html",
                                                       "title":  "Type Messages | OSIsoft Message Format",
                                                       "keywords":  "Type Messages Types can be created, or deleted. Types do not support updating via OMF. The version field is supplied as meta data only. Once a Type is deleted, any operations on Containers or Data using that Type will fail. The body of a Type message consists of an array of objects. The following keywords are used to define a Type. Name Value id Unique identifier of the Type. version Optional version of the Type stored as metadata. The version must be of format x.x.x.x, where x must be an integer greater than or equal to 0. If omitted version 1.0.0.0 is assumed. classification One of dynamic or static . If omitted, the type cannot be directly created, for example enumerations, base types, and types composed into other types. type Inherited from JSON Schema. Set to object to define a static or dynamic Type. Set to [\"string\", \"integer\"] to define an enumeration. basetypeid Optional id of a previously defined type. Used to inherit properties for Types of the same classification, or inherit from a Type with no classification. name Optional friendly name for the Type. description Optional description for the Type. tags Optional array of strings to tag the Type. metadata Optional key-value pairs associated with the Type. enum Optional array of name/value name value pairs used to define an allowed set of values. Classification should not be set when defining an enum Type. properties Key-value pairs defining the properties of a static or dynamic Type. Required unless the Type defines an enum. The id cannot begin with the character sequence __. This has been reserved for predefined Types. Currently the only supported predefined Type is __Link . The id property is referenced when creating instances of Types in Container and Data messages, or when creating other Types that include this Type as a base type or referenced Type. The version is used to supply information about the Type definition and is stored as meta data. A static classification represents metadata describing a device being observed and should be used to capture data that is descriptive and relatively unchanging. A dynamic classification represents observed or calculated measurements taken from a device that update frequently. The basetypeid is used to support Type inheritance and is an id of previously defined Type. The properties of the base type are then included in the new Type. Circular inheritance or self-referencing is not supported when using basetypeid . If a Type is created for the sole purpose of being referenced by another Type, then classification is not required. If classification is not set, then instance data of that Type cannot be created. If the classification is set to static or dynamic then the classification of each Type must match when using basetypeid to define an inheritance relationship. An enum Type defines a set of name/value name value pairs and is used for properties that have a predefined set of allowed values. The enum Type is created separately so that it can be referenced by multiple properties. Refer to Enum Type for detailed information on defining an enum, and using the reftypeid to relate the enum property with the enum definition. The supported data types and data formats for properties are documented in the Type Properties and Formats Topic. Examples of Type Messages and Property Formats Type Properties and Formats Enum Type Type Message Example"
                                                   },
    "documentation_v12/Types/Type_Msg_Example.html":  {
                                                          "href":  "documentation_v12/Types/Type_Msg_Example.html",
                                                          "title":  "Type Example | OSIsoft Message Format",
                                                          "keywords":  "Type Example In the following example we create 2 static types and a dynamic type. The Type definitions define properties for the isindex and isname qualifiers. Their values will be referenced later when defining instance data and creating relationships. Headers omfversion = 1.2 messagetype = type action = create messageformat = json Body [{ \"id\": \"Plant\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"static\", \"properties\": { \"PlantId\": { \"type\": \"string\", \"isindex\": true }, \"PlantName\": { \"type\": \"string\", \"isname\": true }, \"Address\": { \"type\": \"string\" }, \"Contact\": { \"type\": \"string\" } } }, { \"id\": \"Tank\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"static\", \"properties\": { \"TankName\": { \"type\": \"string\", \"isindex\": true, \"isname\": true }, \"Serial\": { \"type\": \"string\" }, \"Model\": { \"type\": \"string\" } } }, { \"id\": \"TankPressure\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"dynamic\", \"properties\": { \"Timestamp\": { \"type\": \"string\", \"format\":\"date-time\", \"isindex\": true }, \"Pressure\": { \"type\": \"number\", \"name\": \"Tank Pressure\", \"description\": \"Tank Pressure in Pa\", \"uom\": \"pascal\", \"interpolation\": \"Continuous\", \"extrapolation\": \"Forward\", \"maximum\": 20, \"minimum\": 10 } } }] Inheritance Example Properties of a Type definition can reference a previously defined Type using the basetypeid keyword, inheriting static data from another static Type. In this example we reference the previously defined Type \u0027Tank\u0027. The resulting \u0027RectangularTank\u0027 contains the properties TankName, Serial, Model, TankHeight, and Tank Width, similarly the \u0027CylindricalTank\u0027 contains the properties TankName, Serial, Model, and TankDiameter. [{ \"id\":\"RectangularTank\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"static\", \"basetypeid\": \"Tank\", \"properties\": { \"TankHeight\": { \"type\": \"integer\", \"format\":\"int32\", \"uom\":\"ft\" }, \"TankWidth\": { \"type\": \"integer\", \"format\":\"int32\", \"uom\":\"ft\" } } }, { \"id\":\"CylindricalTank\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"classification\": \"static\", \"basetypeid\": \"Tank\", \"properties\": { \"TankDiameter\": { \"type\": \"number\", \"format\":\"float32\" } } }] Reference Example Properties of a Type definition can reference a previously defined Type using the reftypeid . In this example we include the \u0027LocationProperties\u0027 in the \u0027TankV2\u0027 Type, but cannot create instance data of the \u0027LocationProperties\u0027 Type. [{ \"id\":\"LocationProperties\", \"type\":\"object\", \"properties\": { \"Latitude\":{ \"type\":\"number\", \"format\":\"float32\" }, \"Longitude\":{ \"type\":\"number\", \"format\":\"float32\" } } }, { \"id\":\"TankV2\", \"type\":\"object\", \"classification\":\"static\", \"properties\": { \"TankName\": { \"type\": \"string\", \"isname\": true, \"isindex\":true }, \"Serial\": { \"type\": \"string\" }, \"Model\": { \"type\": \"string\" }, \"Location\": { \"reftypeid\":\"LocationProperties\" } } }] Enum Example Properties of a Type definition can reference a previously defined enum using the reftypeid keyword. In this example we define data quality on the \u0027TankPressureV2\u0027 object to be of type \u0027DeviceStatusEnum\u0027. [{ \"id\": \"DeviceStatusEnum\", \"enum\": [ {\"name\": \"Device Connected\", \"value\": 0, \"quality\": \"good\"}, {\"name\": \"Device Failure\", \"value\": 1, \"quality\": \"bad\"}, {\"name\": \"Uncertain - Out Limits\", \"value\": 3, \"quality\": \"questionable\"} ] }, { \"id\": \"TankPressureV2\", \"version\": \"1.0.0.0\", \"type\": \"object\", \"basetypeid\": \"TankPressure\", \"classification\": \"dynamic\", \"properties\": { \"DeviceStatus\": { \"reftypeid\": \"DeviceStatusEnum\", \"isquality\": true } }]"
                                                      },
    "documentation_v12/Types/Type_Properties_and_Formats.html":  {
                                                                     "href":  "documentation_v12/Types/Type_Properties_and_Formats.html",
                                                                     "title":  "Type Properties and Formats | OSIsoft Message Format",
                                                                     "keywords":  "Type Properties and Formats The following keywords are used to the define the properties in the Type definition: Name Value type Type of the Property. Must match a type listed in the \u0027Supported Formats\u0027 table below. Either type or reftypeid is required for each property. format Optional format of the type Property that, if specified, must be from the \u0027Supported Formats\u0027 table below. reftypeid id to a previously defined Type. Either type or reftypeid is required for each property. isindex At least one Type Property must be designated as the index, or the Type cannot be used to create instance data. The designated isindex boolean property is used to uniquely identify discrete Data objects so that they can be updated or deleted after their initial creation. For a compound index, the order of index properties within the message determines the order within the index. isname One Type Property may optionally be designated as the name by specifying a boolean value of true. Because the index must be unique across all Data objects, the isname keyword allows for multiple distinct Data objects to share a common name. isquality One Type Property may optionally be designated as the quality. This property would then determine the overall quality of each data value, and must be an enumeration Type. Use the enum to define the values as good , bad or questionable . name Optional friendly name for the Type Property. This property can be overridden using the propertyoverrides keyword on a Container message. description Optional description for the Type Property. This property can be overridden using the propertyoverrides keyword on a Container message. uom Optional unit of measure for the Type Property. This property can be overridden using the propertyoverrides keyword on a Container message. minimum Optional type qualifier that defines minimum allowed value. This property can be overridden using the propertyoverrides keyword on a Container message. This property is only valid on numbers and integers. maximum Optional type qualifier that defines maximum allowed value. This property can be overridden using the propertyoverrides keyword on a Container message. This property is only valid on numbers and integers. interpolation Optional data mode used to provide consistency when reading data. Supported values include continuous , discrete , stepwisecontinuousleading , and stepwisecontinuousfollowing . extrapolation Optional data mode used to provide consistency when reading values. Supported values include all , none , forward , and backward . For each property, type or reftypeid must be defined. When using type refer to the \u0027Supported Formats\u0027 table below for the list of allowed values. When using reftypeid , the value must be set to the id of a previously defined Type. Circular inheritance or self-referencing is not supported when using reftypeid . If type is used, the format of the type may be set using the format keyword, as described in the \u0027Supported Formats\u0027 table below. This allows for the creation of timestamps, dictionaries, and bit length-specific numeric properties. If reftypeid is used, set the value to the id of a previously defined Type. If the referenced type is an enum then it defines the allowed set of data values for this property. If the referenced type is a static or dynamic Type, then the properties of that Type are included as child properties of this property. Supported Formats Type Format Default Value Description array null An array of objects. The required items keyword defines the type of the objects in the array. boolean false A value of either \"true\" or \"false\". integer int64 0 64-bit integer. integer int32 (default) 0 32-bit integer. integer int16 0 16-bit integer. integer uint64 0 64-bit unsigned integer. integer uint32 0 32-bit unsigned integer. integer uint16 0 16-bit unsigned integer. number float64 0 64-bit floating point. number float32 (default) 0 32-bit floating point. number float16 0 16-bit floating point. object dictionary null A dictionary of objects, indexed by a string key. The additionalProperties keyword defines the dictionary\u0027s value type. string null A string. string date-time 0001-01-01T00:00:00Z A string representation of a timestamp, formatted as YYYY-MM-DDThh:mm:ssZ, with optional subsecond precision. Nullable type properties Nullable type properties are supported by specifying an array that defines the datatype and includes the keyword null . The datatype and null may appear in any order in the array. The default value for any nullable type is null. For example: \"MeasurementValue\": {\"type\": [\"integer\", \"null\"], \"format\": \"int64\"} \"MeasurementValue\": {\"type\": [\"null\", \"integer\"], \"format\": \"int64\"} Values of type \"string\" are treated as inherently nullable thus the additional null type specification is not needed. Type reuse and Inheritance Type reuse and Type inheritance are supported for Types of the same classification or Types with no classification , using either basetypeid on a Type Message, or reftypeid at the Property level. When basetypeid is used on a Type, then all the properties of the base type are included within the new Type. When reftypeid is used on a property, then all the properties of the reference type are included under the specified property. In the example below, basetypeid is used to create the new \u0027CylindricalTank\u0027 Type which will have all the properties of the existing \u0027Tank\u0027 Type, maintain the index and name properties, plus adds an additional property \u0027TankDiameter\u0027. { \"id\": \"Tank\", \"type\": \"object\", \"classification\": \"static\", \"properties\": { \"TankName\": { \"type\": \"string\", \"isname\": true, \"isindex\":true }, \"Serial\": { \"type\": \"string\" }, \"Model\": { \"type\": \"string\" } } }, { \"id\":\"CylindricalTank\", \"type\": \"object\", \"classification\": \"static\", \"basetypeid\": \"Tank\", \"properties\": { \"TankDiameter\": { \"type\": \"number\", \"format\":\"float32\" } } } In the example below, a reusable type \u0027LocationProperties\u0027 is created then used with the \u0027TankV2\u0027 definition via the reftypeid to define a Location property on a Tank. The TankV2 Location property will contain the sub properties \u0027Latitude\u0027 and \u0027Longitude\u0027. The referenced type \u0027LocationProperties\u0027 does not define a classification, and does not define an index property and therefore \u0027LocationProperites\u0027 cannot be used as the Type for instance data. { \"id\":\"LocationProperties\", \"type\":\"object\", \"properties\": { \"Latitude\":{ \"type\":\"number\", \"format\":\"float32\" }, \"Longitude\":{ \"type\":\"number\", \"format\":\"float32\" } } }, { \"id\":\"TankV2\", \"type\":\"object\", \"classification\":\"static\", \"properties\": { \"TankName\": { \"type\": \"string\", \"isname\": true, \"isindex\":true }, \"Serial\": { \"type\": \"string\" }, \"Model\": { \"type\": \"string\" }, \"Location\": { \"reftypeid\":\"LocationProperties\" } } } Type Qualifiers Properties with isindex keyword designate that property as the index and must have unique values. The index value is set when creating instances of the Type, and referenced when creating links. Typically, the properties of a dynamic type index on time, and use the format date-time , and properties of a static type index on id or name. Types without an index property cannot be used to create instance data. The isquality keyword is used to designate a particular property as the data quality for the Type. Properties marked with the quality flag should have a reference a reference to an enum . The quality of each enum value is indicated in the enum type definition. Refer to the Enum Type for additional information about defining enums. The following format is supported: \"DeviceStatus\": { \"reftypeid\":\"DeviceStatusEnum\", \"isquality\": true }"
                                                                 },
    "documentation_v12/Whats_New.html":  {
                                             "href":  "documentation_v12/Whats_New.html",
                                             "title":  "What\u0027s New | OSIsoft Message Format",
                                             "keywords":  "What\u0027s New Version 1.2 introduces the following incremental changes from version 1.1: Enhancements for Type messages: Ability to support Type Inheritance using basetypeid defined on a Type Message , and Type Reuse using reftypeid defined on a Property within a Type message. Addition of the enum keyword defined on a Type Message , used to create a reusable set of allowed values, and reference the enum as the datatype for a Property using reftypeid . Ability to designate a property as holding data quality using isquality defined on a Property , and the ability to reference a set of quality values defined using an enum Type Message . Support for minimum and maximum type qualifiers defined on a Property , used to restrict data values. Support for interpolation and extrapolation modes defined on a Property , used to categorize the behavior of data being stored. Enhancements for Container messages: Ability to override values of properties defined by a dynamic Type using the propertyoverrides keyword in the Container Message . Currently supported property overrides include name , description , uom , minimum , and maximum . Ability to set the source of a stream of data using the datasource keyword defined on a Container Message . Enhancements for Data messages: Addition of the property keyword in the __Link Data Message used to link Types and Instances of Types to a particular property. When linking to properties, the link can be defined by property to property, or defined by property to Type. Support for type-less static data values to be sent in a Data Message using the new keyword properties within the Data Message. Deprecated Features in OMF v1.2 specification: Specifying the version of a type when it is referenced is no longer supported. Types are considered immutable and can be referenced by their typeid alone. The producertoken field in the message header has been obsoleted, and is no longer supported."
                                         },
    "index.html":  {
                       "href":  "index.html",
                       "title":  "OSIsoft Message Format | OSIsoft Message Format",
                       "keywords":  "OSIsoft Message Format Overview The OSIsoft Message Format (OMF) defines a set of message headers and bodies that can be used to generate messages for ingestion into a compliant back-end system. OMF can be used to develop data acquisition applications on platforms and in languages for which there are no supported OSIsoft libraries. OMF itself does not define or depend on any particular binary message protocol (HTTP, AMQP, Kafka, etc.) It is instead based on an abstract message type, where a message consists of a set of key /   value pairs, called the headers, and a binary payload, called the body. OMF messages can thus be constructed using any message protocol that defines headers and bodies. For up to date information on the specific binary protocols currently supported by OSIsoft systems, consult the OSIsoft Cloud Services and PI Web API documentation. Please note that anything defined in this document, such as keywords and enumerated values, is treated as case insensitive. Case sensitivity for all user specified values is determined by the rules of the backend system. OMF Specification (1.1) Whats New Message Headers Message Types Type Messages Link Type Type Properties and Formats Type Example Container Messages Container Example Data Messages Data Example HTTP Behaviors While the OMF specification does not define a particular binary message protocol, OSIsoft systems accepting OMF over HTTP conform to a set of behaviors described in this section. Message Size HTTP Status Codes"
                   },
    "README.html":  {
                        "href":  "README.html",
                        "title":  "OMF-Docs | OSIsoft Message Format",
                        "keywords":  "OMF-Docs The OSIsoft Message Format (OMF) defines a set of message headers and bodies that can be used to generate messages for ingestion into a compliant system. This repository contains the documentation for OMF. You can access a readable version of this documentation here. License ?? 2018 - 2021 OSIsoft, LLC. All rights reserved. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 http:  www.apache.org licenses LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."
                    }
}
